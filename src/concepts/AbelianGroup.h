/*    This file is part of the KUMQUAT Library - https://kumquat.inria.fr/ 
 *    - released under  GNU GENERAL PUBLIC LICENSE v.3
 *    See file LICENSE or go to https://kumquat.inria.fr/licensing/ for full 
 *    license details.
 *    Author(s):       Cl√©ment Maria
 *
 *    Copyright (C) 2023 Inria
 *
 *    Modification(s):
 *      - YYYY/MM Author: Description of the modification
 */

namespace kumquat {

/** Concept for an abelian group (algebra), with additive notation (A,+). 
 * 
 * As a group with multiplication, the concept Ring inherits all types and 
 * methods from the concept AbelianGroup. */
struct AbelianGroup {
/** A signed integer type, in particular for the Z-module structure.*/
  typedef unspecified Integer;
/** The type of elements of the group. Must be copiable. */
	typedef unspecified Element;
/** A container to store Elements. */
	// typedef unspecified Element_container;
/**A handle to point at Element, must be of type Element_container::iterator. */
	// typedef unspecified Element_handle;
/** Return the additive identity 0.*/
  Element additive_identity();
/** Set a <- (a+b). */	
	void plus_equal(Element & a, Element b);
/** Return a+b.*/
	Element plus(Element a, Element b);
/** Set a<- z*a using the Z-module structure of the group.*/
	void times_equal(Element a, Integer z);
/** Return z*a using the Z-module structure of the group.*/
	Element times(Element a, Integer z);
/** Return the additive inverse (-a) of element a. */
 Element additive_inverse(Element a);
/** Return the order of the group. It will return the number of element in a finite abelian group, or -1 in case the group is infinite. */
	Integer order();
/** Return the order of the Element a. It will return the order of the group generated by a if it is finite, or -1 if it is infinite.*/
	Integer order(Element a);
/** Return the rank of the group, i.e., the minimal number of generators. */
 Integer rank(); 
/** Return a container of Element that form a minimal family of generators for the group. */
	// Element_container generators();
/** Return true iff the Element is equal to the additive identity.*/
	// bool is_additive_identity(Element a);
/** Return true iff a and b represent the same element of the group.*/
  bool equal(Element a, Element b);
/** Convert an integer to an element of the group, equal to z*1.*/
  Element element(Integer z);
/** Check whether an element is trivial.*/
  bool trivial(Element a);

};

} //namespace kumquat
