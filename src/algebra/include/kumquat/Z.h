/*    This file is part of the KUMQUAT Library - https://kumquat.inria.fr/ 
 *    - released under  GNU GENERAL PUBLIC LICENSE v.3
 *    See file LICENSE or go to https://kumquat.inria.fr/licensing/ for full 
 *    license details.
 *    Author(s):       Cl√©ment Maria
 *
 *    Copyright (C) 2023 Inria
 *
 *    Modification(s):
 *      - YYYY/MM Author: Description of the modification
 */

#ifndef KUMQUAT_Z_H_ 
#define KUMQUAT_Z_H_

#include <vector>
#include <numeric>
#include <boost/multiprecision/gmp.hpp>

namespace kumquat {

/** \brief Algebraic structure Z with multiprecision arithmetic.
 *
 * The structure is an abelian group for +, and a ring for *.
 * 
 * Elements of the ring Z are represented by integers (multiprecision gmp).
 *
 * \implements Ring
 */
class Z {
public:
  Z() {}
  /** An integer type, in particular for the Z-module structure.*/
  typedef int Integer;
  /** The type of elements of the ring. Must be copiable. */
  typedef boost::multiprecision::mpz_int Element;
  /** Return the additive identity 0.*/
  Element additive_identity() { return 0; }
  /** Set a <- (a+b). */  
  void plus_equal(Element & a, Element b) { a += b; }
  /** Return a+b.*/
  Element plus(Element a, Element b) { return a+b; }
  /** Set a<- z*a using the Z-module structure of the group.*/
  void times_equal(Element a, Integer z) { a *= z; }
  /** Return z*a using the Z-module structure of the group.*/
  Element times(Element a, Integer z) { return a*z; }
  /** Return the additive inverse (-a) of element a. */
   Element additive_inverse(Element a) { return (-1)*a; }
/** Return the order of the group. It will return the number of element in a finite abelian group, or -1 in case the group is infinite. */
  Integer order() { return -1; }
/** Return the order of the Element a. It will return the order of the group generated by a if it is finite, or -1 if it is infinite.*/
  Integer order(Element a) { 
    if(a==0) { return 0; }
    return -1; 
  }
/** Return the rank of the group, i.e., the minimal number of generators. */
  Integer rank() { return 1; } 
/** Return the multiplicative identity 1.*/
  Element multiplicative_identity() { return 1; }
/** Set a <- (a*b). */
  void times_equal(Element & a, Element b) { a *= b; }
/** Return a*b.*/
  Element times(Element a, Element b) { return a*b; }
/** Set a <- a^p. */
  void pow_equal(Element & a, Integer p) { a = boost::multiprecision::pow(a,p);}
/** Return a <- a^p for a positive integer p. */
  Element pow(Element a, Integer p) { 
    return boost::multiprecision::pow(a,p); 
  }
/** Return the multiplicative inverse of a Element a if it exists, and return the additive identity 0 otherwise.*/
  Element multiplicative_inverse(Element a) {
    if(a == 1 || a == -1) { return a; }
    return 0;
  }
/** Convert an integer to an element of the ring Z.*/
  Element element(Integer z) { return Element(z); }
/** Check equality of two elements.*/
  bool equal(Element a, Element b) {
    return a==b;
  }
};

}  //namespace kumquat

#endif //KUMQUAT_Z_H_