/*    This file is part of the KUMQUAT Library - https://kumquat.inria.fr/ 
 *    - released under  GNU GENERAL PUBLIC LICENSE v.3
 *    See file LICENSE or go to https://kumquat.inria.fr/licensing/ for full 
 *    license details.
 *    Author(s):       Cl√©ment Maria
 *
 *    Copyright (C) 2023 Inria
 *
 *    Modification(s):
 *      - YYYY/MM Author: Description of the modification
 */

#ifndef KUMQUAT_Z_H_ 
#define KUMQUAT_Z_H_

#include <vector>
#include <numeric>
#include <boost/multiprecision/gmp.hpp>//boost multiprecision wrap over gmp
#include <boost/integer/extended_euclidean.hpp>//boost extended gcd

namespace kumquat {

/** \brief Algebraic structure Z with multiprecision arithmetic.
 *
 * The structure is an abelian group for +, and a ring for *.
 * 
 * Elements of the ring Z are represented by integers (multiprecision gmp).
 *
 * \implements Ring
 */
class Z {
public:
  Z() {}
  /** An integer type, in particular for the Z-module structure.*/
  typedef int Integer;
  /** The type of elements of the ring. Must be copiable. */
  typedef boost::multiprecision::mpz_int Element;
  /** Return the additive identity 0.*/
  Element additive_identity() { return 0; }
  /** Set a <- (a+b). */  
  void plus_equal(Element & a, Element b) { a += b; }
  /** Return a+b.*/
  Element plus(Element a, Element b) { return a+b; }
  /** Set a<- z*a using the Z-module structure of the group.*/
  void times_equal(Element a, Integer z) { a *= z; }
  /** Return z*a using the Z-module structure of the group.*/
  Element times(Element a, Integer z) { return a*z; }
  /** Return the additive inverse (-a) of element a. */
   Element additive_inverse(Element a) { return (-1)*a; }
/** Return the order of the group. It will return the number of element in a finite abelian group, or -1 in case the group is infinite. */
  Integer order() { return -1; }
/** Return the order of the Element a. It will return the order of the group generated by a if it is finite, or -1 if it is infinite.*/
  Integer order(Element a) { 
    if(a==0) { return 0; }
    return -1; 
  }
/** Return the rank of the group, i.e., the minimal number of generators. */
  Integer rank() { return 1; } 
/** Return the multiplicative identity 1.*/
  Element multiplicative_identity() { return 1; }
/** Set a <- (a*b). */
  void times_equal(Element & a, Element b) { a *= b; }
/** Return a*b.*/
  Element times(Element a, Element b) { return a*b; }
/** Set a <- a^p. */
  void pow_equal(Element & a, Integer p) { a = boost::multiprecision::pow(a,p);}
/** Return a <- a^p for a positive integer p. */
  Element pow(Element a, Integer p) { 
    return boost::multiprecision::pow(a,p); 
  }
/** Return the multiplicative inverse of a Element a if it exists, and return the additive identity 0 otherwise.*/
  Element multiplicative_inverse(Element a) {
    if(a == 1 || a == -1) { return a; }
    return 0;
  }
/** Convert an integer to an element of the ring Z.*/
  Element element(Integer z) { return Element(z); }
/** Check equality of two elements.*/
  bool equal(Element a, Element b) {
    return a==b;
  }
/** Check whether an element is trivial.*/
  bool trivial(Element a) { return a == 0; }

/** \brief Return the absolute value of an integer. 
 * 
 * Plays the role of the Euclidean function for the structure of the PID. See functions division and remainder*/
  Element abs(Element a) { 
    if(a < 0) { times_equal(a,-1); }
    return a;
  }
/** \brief Compute the extended greatest common divisor of two elements of 
 * the ring. 
 * 
 * Return a triple (u,v,gcd) opf ring elements such that gcd is the greatest 
 * common divisor of x and y, and (u,v) satiosfies the Bezout identity:
 * u*x + v*y = gcd, for + the ring addition and * the ring multiplication. 
 * */ 
  std::tuple<Element,Element,Element> extended_gcd(Element x, Element y) {
    auto res_boost = boost::integer::extended_euclidean(x, y);
    std::tuple<Element,Element,Element> res(res_boost.x, res_boost.y, 
                                            res_boost.gcd); 
    return res;
  }
/** \brief Compute the division x/y in the PID.
 * 
 * Return the value q such that x = q*y + r, with 0 \leq r < |y|.*/ 
  Element division(Element x, Element y) {
    return x/y;
  }
/** \brief Compute the remainder of the division x/y in the PID.
 * 
 * Return the value r such that x = q*y + r, with 0 \leq r < |y|.
 * */ 
  Element remainder(Element x, Element y) {
    return x%y;
  }

};

}  //namespace kumquat

#endif //KUMQUAT_Z_H_