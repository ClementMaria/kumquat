/*    This file is part of the KUMQUAT Library - https://kumquat.inria.fr/ 
 *    - released under  GNU GENERAL PUBLIC LICENSE v.3
 *    See file LICENSE or go to https://kumquat.inria.fr/licensing/ for full 
 *    license details.
 *    Author(s):       Cl√©ment Maria
 *
 *    Copyright (C) 2023 Inria
 *
 *    Modification(s):
 *      - YYYY/MM Author: Description of the modification
 */

#ifndef KUMQUAT_Q_MOD_Z_H_ 
#define KUMQUAT_Q_MOD_Z_H_

#include <vector>
#include <numeric>
#include <boost/multiprecision/gmp.hpp>

namespace kumquat {

/** \brief Algebraic structure \f$\mathbb{Q}_{(p)}/\mathbb{Z}\f$ for a prime p>0.
 *
 * The structure is an abelian group for +, a ring for *, and a field if n is prime.
 * 
 * Elements of the ring Z/nZ are represented by integers (int), between 0 and n-1. 
 * If n is prime, all element of the ring are invertible and Z/nZ is a field.
 *
 * \implements AbelianGroup
 */
class Q_mod_Z {
public:
  Q_mod_Z() {}
/** An integer type, in particular for the Z-module structure.*/
  typedef int Integer;
/** The type of elements of the ring, represented by a pair of multiprecision integers (x,y), representing the fraction x/y, with 0 <= x < y. We do not however enforce that gcd(x,y) == 1. Must be copiable. */
  typedef std::pair< boost::multiprecision::mpz_int,
                     boost::multiprecision::mpz_int >   Element;
/** Return the additive identity 0.*/
  Element additive_identity() { return Element(0,1); }
/** Set a <- (a+b). */  
  void plus_equal(Element & a, Element b) { 
    a.first = a.first*b.second + a.second*b.first;
    a.second *= b.second;  
    normalize_element(a);
  }

/** Return a+b.*/
  Element plus(Element a, Element b) { 
    Element a_plus_b(a.first*b.second + a.second*b.first, a.second * b.second);
    normalize_element(a_plus_b);
    return a_plus_b; 
  }
/** Set a<- z*a using the Z-module structure of the group.*/
  void times_equal(Element & a, Integer z) { 
    a.first *= z; 
    normalize_element(a); 
  }
/** Return z*a using the Z-module structure of the group.*/
  Element times(Element a, Integer z) { 
    a.first *= z; 
    normalize_element(a); 
    return a;
  }
/** Return the additive inverse (-a) of element a. */
  Element additive_inverse(Element a) { 
    if(a.first == 0) return additive_identity();
    return Element(a.second - a.first, a.second); //1-a
  }
/** Check for equality. Note that the element 0 is ambiguous, as it can be represented by any fraction 0/x with x != 0.*/
  bool equal(Element a, Element b) {
    if(a.first == 0) { return b.first == 0; }
    return (a.first * b.second) == (b.first * a.second);
  }
/** Return the order of the group. It will return the number of element in a finite abelian group, or -1 in case the group is infinite. */
  Integer order() { return -1; }
/** Return the order of the Element a. It will return the order of the group generated by a if it is finite, or -1 if it is infinite.*/
  Integer order(Element a) { 
    if(a.first == 0) { return 0; }
    auto order_mp = (a.second / boost::multiprecision::gcd(a.first,a.second));
    return (Integer)order_mp; 
  }


/** Return the rank of the group, i.e., the minimal number of generators. */
  Integer rank() { return -1; } 
// /** Set a <- (a*b). */
//     void times_equal(Element & a, Element b) { a *= b; }
// /** Return a*b.*/
//     Element times(Element a, Element b) { return a*b; }
// /** Set a <- a^p. */
//     void pow_equal(Element & a, Integer p) { 
//       a = Q_mod_Z::pow(a,p);
//     }
// /** Return a <- a^p for a positive integer p. */
//     Element pow(Element a, Integer p) { 
//       return boost::multiprecision::pow(a,p); 
//     }
// /** Return the multiplicative inverse of a Element a if it exists, and return the additive identity 0 otherwise.*/
//     Element multiplicative_inverse(Element a) {
//       if(a == 0) { return 0; }
//       return Element( a.second % a.first, a.first );
//     }

    Element element(Integer z) { return Element(0,1); }

    Element element(Integer a, Integer b) { return Element(a % b,b); }

private:
  /** Normalize the elemnt a modulo Z. Note that we do not enforce that 
   * gcd(a.first,a.second) == 1.
   */
  void normalize_element(Element & a) {
    if(a.first >= a.second) { a.first = (a.first) % (a.second); }
  }

};

/** \brief Write ....*/
std::ostream & operator<<(std::ostream & os, Q_mod_Z::Element & a) {
      os << a.first << " / " << a.second;
  return os;
}


}  //namespace kumquat


#endif //KUMQUAT_Q_MOD_Z_H_
