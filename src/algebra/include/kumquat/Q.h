/*    This file is part of the KUMQUAT Library - https://kumquat.inria.fr/ 
 *    - released under  GNU GENERAL PUBLIC LICENSE v.3
 *    See file LICENSE or go to https://kumquat.inria.fr/licensing/ for full 
 *    license details.
 *    Author(s):       Cl√©ment Maria
 *
 *    Copyright (C) 2023 Inria
 *
 *    Modification(s):
 *      - YYYY/MM Author: Description of the modification
 */

#ifndef KUMQUAT_Q_H_ 
#define KUMQUAT_Q_H_

#include <string>
#include <vector>
#include <numeric>
#include <boost/multiprecision/gmp.hpp>
#include <kumquat/number_theory.h>
#include <sstream>

namespace kumquat {

/** \class Q Q.h kumquat/Q.h 
  * \brief Field of rational numbers \f$\mathbb{Q}\f$.
  *
  * The structure is a field \f$(\mathbb{Q},0,+,\times,1)\f$.
  * 
  * Elements are represented by pairs of multiprecision non-negative integers (x,y), 
  * representing fractions \f$x/y\f$, with \f$0 < y\f$ and gcd(x,y) = 1.
  *
  * \implements Ring
  * 
  * template IntegerNumber implements IntegerNumber
  */
template<typename IntegerNumber>
class Q {
public:
  static const bool abelian_group = true;
  static const bool pseudo_ring = true;//multiplication undefined a/b*c/d != a/b*(c+d)/d
  static const bool ring = true;
  static const bool principal_ideal_domain = true;
  static const bool field = true;//the multiplicative inverse always exists, except for 0

/** \brief Initialization of the entire group \f$\mathbb{Q}/\mathbb{Z}\f$.
  * 
  * p_ set to -1 indicates that we construct the entire group.
  * */
  Q() {}

/** \name Methods for Abelian groups. Implements AbelianGroup.
 * @{ */

/** \brief A (multiprecision) signed integer type, notably for the outer product 
  * encoding the \f$Z\f$-module structure of Abelain groups.
  * 
  * int must be convertible to Integer. Integer must be compatible with the usual 
  * operators +, -, *, / etc. 
  * */
  typedef IntegerNumber Integer;
/** \brief The type of elements of the group.
  * 
  * Elements are represented by a pair of multiprecision integers \f$(x,y)\f$, 
  * representing the fraction \f$x/y\f$, with \f$0 < y\f$ and \f$gcd(x,y) = 1\f$. 
  * 
  * The additive inverse is 0/1.
  * 
  * Must be copiable. 
  * */
  typedef std::pair< Integer, Integer >   Element;
/** \brief Return the additive identity 0.
 * 
 * The additive identity can be represented by any pair of integers (0,y) with 
 * \f$y>0\f$.
 * */
  Element additive_identity() { return Element(0,1); }
/** \brief Set \f$a \leftarrow (a+b)\f$. */  
  void plus_equal(Element & a, Element b) { 
    a.first = a.first*b.second + a.second*b.first;
    a.second *= b.second;  
    normalize(a);
  }
/** \brief Return \f$a+b\f$.*/
  Element plus(Element a, Element b) { 
    Element a_plus_b(a.first*b.second + a.second*b.first, a.second * b.second);
    normalize(a_plus_b);
    return a_plus_b; 
  }
/** \brief Set \f$a \leftarrow z \times a\f$, using the \f$Z\f$-module structure of 
 * the group.
 * */
  void times_equal(Element & a, Integer z) { 
    a.first *= z; 
    normalize(a); 
  }
/** \brief Return \f$ z \times a\f$, using the \f$Z\f$-module structure of the 
 * group.
 * */
  Element times(Element a, Integer z) { 
    a.first *= z; 
    normalize(a); 
    return a;
  }
/** \brief Return the additive inverse (-a) of an element a. */
  Element additive_inverse(Element a) { 
    if(a.first == 0) return additive_identity();
    return times(a,-1);
  }
/** \brief Return the order of the group. 
 * 
 * It will return the number of element in a finite abelian group, or -1 in case the 
 * group is infinite. 
 * */
  Integer order() { return -1; }
/** \brief Return the order of the Element a. 
 * 
 * It will return the order of the group generated by a if it is finite, or -1 if it 
 * is infinite.
 * */
  Integer order(Element a) { 
    if(a.first == 0) { return 0; }
    return -1;
  }
/** \brief Return the rank of the group, i.e., the minimal number of generators. 
 * 
 * Return -1 if the rank is infinite.
 * */
  Integer rank() { return -1; } 
/** Check for equality. Note that the element 0 is ambiguous, as it can be 
 * represented by any fraction /f$0/y/f$ with for any /f$y > 0/f$.
 * */
  bool equal(Element a, Element b) {
    if(a.first == 0) { return b.first == 0; }
    return (a.first * b.second) == (b.first * a.second);
  }
/** \brief Converts an Integer into an element of the group.
 * 
 * This input integer is unused as all integers are converted to 0.
 */
  Element element(Integer z) { return Element(z,1); }
/** \brief Return true iff the input a is equal to the additive identity 0.*/
  bool trivial(Element a) { return a.first == 0; }
  bool trivial(Integer z) { return z == 0; }
/* @} */  // end AbelianGroup methods
/** \name Methods for pseudo rings. Implements PseudoRing.
 * @{ */

/** Set a <- (a*b). */
  void times_equal(Element & a, Element b) {
    a.first = a.first * b.first;
    a.second = a.second * b.second;
    normalize(a);
  }
// /** Return a*b.*/
  Element times(Element a, Element b) {
    a.first = a.first * b.first;
    a.second = a.second * b.second;
    normalize(a);
    return a;
  }
/** Set a <- a^p. */
    void pow_equal(Element & a, Integer p) {
      a.first = kumquat::pow(a.first,p);
      a.second = kumquat::pow(a.second,p);
    }
/** Return a <- a^p for a positive integer p. */
    Element pow(Element a, Integer p) {
      a.first = kumquat::pow(a.first,p);
      a.second = kumquat::pow(a.second,p);
      return a;
    }
/* @} */  // end pseudo ring methods
/** \name Methods for rings. Implements Ring.
 * @{ */
/** Return the multiplicative identity 1.*/
    Element multiplicative_identity() {
      return Element(1,1);
    }
/** Return the multiplicative inverse of a Element a if it exists, and return the additive identity 0 otherwise.*/
    Element multiplicative_inverse(Element a) {
      if(trivial(a)) return additive_identity();
      return Element(a.second,a.first);
    }
/* @} */  // end ring methods


/** \name Methods specific to Q
 * @{ */
/** \brief Construct the Element \f$x/y\f$ from two integers 
 * /f$x/f$ and /f$y/f$.
 * */ 
  Element element(Integer x, Integer y) { 
    Element z(x,y);
    normalize(z);
    return z; 
  }
/** \brief Normalize a fraction u/v into x/y such that:
 * u/v = x/y, and gcd(x,y) = 1, and 0 < y.
 */ 
  void normalize(Element & a) {
    normalize_fraction(a);
  }

/** \brief Return the numerator of a fraction.*/
  Integer numerator(Element a) { return a.first; }
/** \brief Return the denominator of a fraction.*/
  Integer denominator(Element a) { return a.second; }
/* @} */  // end methods specific to Q.

/** \brief Return a string encoding the fraction.*/
  std::string to_string(Element x) {
    return std::to_string(x.first) + "/" + std::to_string(x.second);
  }

private:
  /* Normalize the fraction such that gcd(numerator,denominator) = 1. 
   */
  void normalize_fraction(Element & a) {
    if(a.first == 0) { a.second = 1; return; }
    auto gcd = kumquat::gcd(a.first,a.second);
    if(gcd != 1) {
      a.first /= gcd;
      a.second /= gcd;
    }
    if(a.second < 0) { a.first *= -1; a.second *= -1; }
  }
};

/** \brief Write an Element of Q_mod_Z into a stream, as an unnormalized fraction 
 * x / y.
 * */
// template<typename IntegerNumber>
// std::ostream & operator<<( std::ostream & os, 
//                            typename Q_mod_Z<IntegerNumber>::Element & a) {
//       os << a.first << "/" << a.second;
//   return os;
// }
// template<typename IntegerNumber>
// std::ostream & operator<<( std::ostream & os, 
//                            std::pair<IntegerNumber,IntegerNumber> & a) {
  
//   std::stringstream ss;//for alignment purpose
//   ss << a.first << "/" << a.second;  
//   os << ss.str();
//   return os;
// }

typedef Q<boost::multiprecision::mpz_int> Q_mp;

}  //namespace kumquat

#endif //KUMQUAT_Q_MOD_Z_H_
