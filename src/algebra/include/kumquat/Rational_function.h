/*    This file is part of the KUMQUAT Library -
 *    https://kumquat.inria.fr/ 
 *    - which is a licence protected library. See file LICENSE 
 *    or go to https://kumquat.inria.fr/licensing/ for full 
 *    license details.
 *
 *    Author(s):       Cl√©ment Maria
 *
 *    Copyright (C) 2024 Inria
 *
 *    Modification(s):
 *      - YYYY/MM Author: Description of the modification
 */

#ifndef KUMQUAT_R_H_ 
#define KUMQUAT_R_H_

#include <string>
#include <vector>
#include <numeric>
#include <boost/multiprecision/gmp.hpp>
#include <kumquat/number_theory.h>
#include <sstream>
#include <cmath>
// #include <boost/math/bindings/mpfr.hpp>

namespace kumquat {

/** \class Rational_function Rational_function.h kumquat/Rational_function.h 
  * \brief Field of rational functions \f$\mathbb{Q}(X)\f$.
  *
  * The structure is a field \f$(\mathbb{Q}(X),0/1,+,\times,1/1)\f$.
  * 
  * Uses Rational_function_integral_mp as base scalar type.
  * 
  * \implements Ring
  */
class Rational_function {
public:
  static const bool abelian_group = true;
  static const bool pseudo_ring = true;//multiplication undefined a/b*c/d != a/b*(c+d)/d
  static const bool ring = true;
  static const bool principal_ideal_domain = true;
  static const bool field = true;//the multiplicative inverse always exists, except for 0

/** \brief Initialization.
  * */
  Rational_function() {}

/** \name Methods for Abelian groups. Implements AbelianGroup.
 * @{ */

/** \brief A (multiprecision) signed integer type, notably for the outer product 
  * encoding the \f$Z\f$-module structure of Abelian groups.
  * 
  * int must be convertible to Integer. Integer must be compatible with the usual 
  * operators +, -, *, / etc. 
  * */
  typedef boost::multiprecision::mpz_int Integer;
/** \brief The type of elements of the group.
  * 
  * Elements are represented by a pair of multiprecision integers \f$(x,y)\f$, 
  * representing the fraction \f$x/y\f$, with \f$0 < y\f$ and \f$gcd(x,y) = 1\f$. 
  * 
  * The additive inverse is 0/1.
  * 
  * Must be copiable. 
  * */
  typedef Rational_function_integral_mp   Element;
/** \brief Return the additive identity 0.
 * 
 * The additive identity can be represented by any pair of integers (0,y) with 
 * \f$y>0\f$.
 * */
  Element additive_identity() { return Element(0); }
/** \brief Set \f$a \leftarrow (a+b)\f$. */  
  void plus_equal(Element & a, Element b) { 
    a += b;
  }
/** \brief Return \f$a+b\f$.*/
  Element plus(Element a, Element b) { 
    return a+b;
  }
/** \brief Set \f$a \leftarrow z \times a\f$, using the \f$Z\f$-module structure of 
 * the group.
 * */
  void times_equal(Element & a, Integer z) { 
    a *= z;
  }
/** \brief Return \f$ z \times a\f$, using the \f$Z\f$-module structure of the 
 * group.
 * */
  Element times(Element a, Integer z) { 
    return a*z;
  }
/** \brief Return the additive inverse (-a) of an element a. */
  Element additive_inverse(Element a) { 
    if(a == 0) return additive_identity();
    return times(a,(Integer)(-1));
  }
/** \brief Return the order of the group. 
 * 
 * It will return the number of element in a finite abelian group, or -1 in case the 
 * group is infinite. 
 * */
  Integer order() { return -1; }
/** \brief Return the order of the Element a. 
 * 
 * It will return the order of the group generated by a if it is finite, or -1 if it 
 * is infinite.
 * */
  Integer order(Element a) { 
    if(a == 0) { return 0; }
    return -1;
  }
/** \brief Return the rank of the group, i.e., the minimal number of generators. 
 * 
 * Return -1 if the rank is infinite.
 * */
  Integer rank() { return -1; } 
/** Check for equality. Note that the element 0 is ambiguous, as it can be 
 * represented by any fraction /f$0/y/f$ with for any /f$y > 0/f$.
 * */
  bool equal(Element a, Element b) {
    return a==b;
  }
/** \brief Converts an Integer into an element of the group.
 * 
 * This input integer is unused as all integers are converted to 0.
 */
  Element element(Integer z) { return Element(z); }
/** \brief Return true iff the input a is equal to the additive identity 0.*/
  bool trivial(Element a) { return a == 0; }
  bool trivial(Integer z) { return z == 0; }
/* @} */  // end AbelianGroup methods
/** \name Methods for pseudo rings. Implements PseudoRing.
 * @{ */

/** Set a <- (a*b). */
  void times_equal(Element & a, Element b) {
    a *= b;
  }
// /** Return a*b.*/
  Element times(Element a, Element b) {
    return a*b;
  }
/** Set a <- a^p. */
  void pow_equal(Element & a, Integer p) {
    a = kumquat::powf(a,p);
  }
/** Return a <- a^p for a positive integer p. */
  Element pow(Element a, Integer p) {
    return kumquat::powf(a,p);
  }
/* @} */  // end pseudo ring methods
/** \name Methods for rings. Implements Ring.
 * @{ */
/** Return the multiplicative identity 1.*/
    Element multiplicative_identity() {
      return Element(1);
    }
/** Return the multiplicative inverse of a Element a if it exists, and return the additive identity 0 otherwise.*/
    Element multiplicative_inverse(Element a) {
      if(trivial(a)) return additive_identity();
      return 1/a;
    }
/* @} */  // end ring methods


/** \brief Return a string encoding the fraction.
 * 
 * The type Integer must define a valid operator<<.
 * */
  std::string to_string(Element x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
  }

}; 

} //namespace kumquat

#endif //KUMQUAT_Q_MOD_Z_H_
